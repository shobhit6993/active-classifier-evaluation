import numpy
from scipy.stats import bernoulli

class ExponentialClassifierSim(object):
    """Simulates a classifier with accuracy sampled from 
    an exponential distribution.
    
    Attributes:
        accuracy (float): Accuracy of the classifier.
        beta (float): param for exponential distribution, with mean = beta.
        mode (string): 'dense_high_scorers' to favor high accuracy classifier.
            'dense_low_scorers' to favor low accuracy classifier.
    """
    def __init__(self, beta, mode):
        self.beta = beta
        self.mode = mode
        self.accuracy = self.__generate_accuracy()
        self.predicted_label = []
        self.estimated_accuracy = 0.0
        self.num_correct_predictions = 0

    def __generate_accuracy(self):
        """Generates accuracy for the classifier
        
        Accuracy is generated by sampling from a truncated exponential
        distribution. Since exp distribution favors values closer to 0, 
        (1-generated_accuracy) is set as accuracy if mode is dense_high_scorers.
        
        Returns:
            float: Accuracy of the classifier.
        """
        v = numpy.random.exponential(self.beta)
        while v > 1.0:
            v = numpy.random.exponential(self.beta)
            
        if self.mode == 'dense_high_scorers':
            return 1.0 - v
        else:
            return v

    def predict(self, target):
        """Computes label predictions for the classifier and saves them in 
        predicted_label attribute. Since this is a simulated classifier, 
        the predict function, amusingly, takes as argument the gold labels. 
        
        Args:
            target (list): List of gold labels for the dataset of items.
        
        Returns:
            list: Predictions for the classifier..
        """
        prediction = []
        for t in target:
            v = bernoulli.rvs(self.accuracy)
            if v == 1:   # success
                self.predicted_label.append(t)
            else:       # failure
                self.predicted_label.append((t+1) % 2)
